! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! 
! Numerical Integrator (Time-Stepping) File
! 
! Generated by KPP-2.3.1_gc symbolic chemistry Kinetics PreProcessor
!       (http://www.cs.vt.edu/~asandu/Software/KPP)
! KPP is distributed under GPL, the general public licence
!       (http://www.gnu.org/copyleft/gpl.html)
! (C) 1995-1997, V. Damian & A. Sandu, CGRER, Univ. Iowa
! (C) 1997-2005, A. Sandu, Michigan Tech, Virginia Tech
!     With important contributions from:
!        M. Damian, Villanova University, USA
!        R. Sander, Max-Planck Institute for Chemistry, Mainz, Germany
! 
! File                 : ccycle_Integrator.F90
! Equation file        : ccycle.kpp
! Output root filename : ccycle
! 
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
! 
! INTEGRATE - Integrator routine
!   Arguments :
!      TIN       - Start Time for Integration
!      TOUT      - End Time for Integration
! 
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!
!    Forward Euler method for non-stiff ODEs                              !
!                                                                         !
!    Version History:                                                     !
!    Apr. 30, 2022 - Initial Version - M.S.Long                           !
!                                                                         !
!    This implementation is part of KPP - the Kinetic PreProcessor        !
!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!
MODULE ccycle_Integrator

  USE ccycle_Precision, ONLY: dp
  USE ccycle_Parameters, ONLY: NVAR, NFIX, NSPEC
  USE ccycle_Global
  USE ccycle_Monitor
  IMPLICIT NONE
  PUBLIC
  SAVE

  ! description of the error numbers IERR
  CHARACTER(LEN=50), PARAMETER, DIMENSION(1) :: IERR_NAMES = (/ &
    'dummy value                                       ' /)

CONTAINS

  ! **************************************************************************

  SUBROUTINE INTEGRATE( TIN, TOUT, ICNTRL_U, IERR_U )
    IMPLICIT NONE
    
    REAL(kind=dp), INTENT(IN) :: TIN  ! Start Time
    REAL(kind=dp), INTENT(IN) :: TOUT ! End Time
    ! Optional input parameters and statistics
    INTEGER,       INTENT(IN),  OPTIONAL :: ICNTRL_U(20)
    INTEGER,       INTENT(OUT), OPTIONAL :: IERR_U
    ! Local variables
    INTEGER                              :: ICNTRL(20)
    INTEGER                              :: IERR

    ! ICNTRL(1) = verbose error output
    ! ICNTRL(2) = stop at negative integration result

    !~~~> Zero input and output arrays for safety's sake
    ICNTRL     = 0

    IF ( PRESENT( ICNTRL_U ) ) THEN
       WHERE( ICNTRL_U /= 0 ) ICNTRL = ICNTRL_U
    ENDIF

    CALL FORWARDEULER(NVAR,VAR,TIN,TOUT,ICNTRL,IERR)

    IF ( PRESENT( IERR_U ) ) IERR_U  = IERR

  END SUBROUTINE INTEGRATE

  SUBROUTINE FORWARDEULER(N,Y,Tstart,Tend,ICNTRL,IERR)

    ! Input: Arguments
    REAL(kind=dp), INTENT(INOUT) :: Y(N) ! initial condition
    INTEGER,  INTENT(IN)    :: N
    REAL(kind=dp), INTENT(IN)    :: Tstart,Tend
    INTEGER,  INTENT(IN)    :: ICNTRL(20)
    ! Output: 
    INTEGER, INTENT(OUT)    :: IERR ! Error indicator
    ! Local variables
    INTEGER  :: i
    LOGICAL  :: hasNegative
    REAL(kind=dp) :: Ynew(N), dYdt(N)

    !
    hasNegative = .false.
    
    ! Get P-kY
    CALL FunTEMPLATE( Y, dYdt )

    ! Integrate
    Ynew = Y+dYdt*(Tend-Tstart)

    ! Check for negatives
    DO i=1,N
       IF (Ynew(i) .lt. 0._dp) THEN
          hasNegative = .true.
          IF (ICNTRL(1) /= 0) write(*,*) trim(SPC_NAMES(i)), " is negative."
          IERR = -9
          IF (ICNTRL(2) /= 0) THEN
             write(*,*) 'Stopping'
             STOP
          ENDIF
       ENDIF
    ENDDO

    Y = Ynew
    
    ! Succesful exit
    IERR = 1
    
  END SUBROUTINE FORWARDEULER

  !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  SUBROUTINE FunTemplate( Y, Ydot )
    !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    !  Template for the ODE function call.
    !~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    USE ccycle_Parameters, ONLY: NVAR
    USE ccycle_Global,     ONLY: FIX, RCONST
    USE ccycle_Function,   ONLY: Fun
    
    !~~~> Input variables
    REAL(kind=dp) :: Y(NVAR)
    !~~~> Output variables
    REAL(kind=dp) :: Ydot(NVAR)

    CALL Fun( Y, FIX, RCONST, Ydot )

  END SUBROUTINE FunTemplate

END MODULE ccycle_Integrator
! End of INTEGRATE function
! ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


