#INTEGRATOR rosenbrock
#LANGUAGE Fortran90
#DRIVER none
#HESSIAN off
#MEX off
#STOICMAT off

#INCLUDE fullchem.eqn

#FAMILIES
POx : O3 + NO2 + 2NO3 + PAN + PPN + MPAN + HNO4 + 3N2O5 + HNO3 + BrO + HOBr + BrNO2 + 2BrNO3 + MPN + ETHLN + MVKN + MCRHN + MCRHNB + PROPNN + R4N2 + PRN1 + PRPN + R4N1 + HONIT + MONITS + MONITU + OLND + OLNN + IHN1 + IHN2 + IHN3 + IHN4 + INPB + INPD + ICN + 2IDN + ITCN + ITHN + ISOPNOO1 + ISOPNOO2 + INO2B + INO2D + INA + IDHNBOO + IDHNDOO1 + IDHNDOO2 + IHPNBOO + IHPNDOO + ICNOO + 2IDNOO + MACRNO2 + ClO + HOCl + ClNO2 + 2ClNO3 + 2Cl2O2 + 2OClO + O + O1D + IO + HOI + IONO + 2IONO2 + 2OIO + 2I2O2 + 3I2O3 + 4I2O4;
LOx : O3 + NO2 + 2NO3 + PAN + PPN + MPAN + HNO4 + 3N2O5 + HNO3 + BrO + HOBr + BrNO2 + 2BrNO3 + MPN + ETHLN + MVKN + MCRHN + MCRHNB + PROPNN + R4N2 + PRN1 + PRPN + R4N1 + HONIT + MONITS + MONITU + OLND + OLNN + IHN1 + IHN2 + IHN3 + IHN4 + INPB + INPD + ICN + 2IDN + ITCN + ITHN + ISOPNOO1 + ISOPNOO2 + INO2B + INO2D + INA + IDHNBOO + IDHNDOO1 + IDHNDOO2 + IHPNBOO + IHPNDOO + ICNOO + 2IDNOO + MACRNO2 + ClO + HOCl + ClNO2 + 2ClNO3 + 2Cl2O2 + 2OClO + O + O1D + IO + HOI + IONO + 2IONO2 + 2OIO + 2I2O2 + 3I2O3 + 4I2O4;
PCO : CO;
LCO : CO;
PSO4 : SO4;
LCH4 : CH4;
PH2O2 : H2O2;


#INLINE F90_RATES
  ! Not needed in this mechanism; leave commented out for now (bmy, 12/18/20)
  !FUNCTION ARRPLUS( a0, b0, c0, d0, e0 ) RESULT( rate )
  !  ! Modified Arrhenius law
  !  ! Use when Arrhenius parameters b0 and c0 are both nonzero
  !  REAL(kind=dp), INTENT(IN) :: a0, b0, c0, d0, e0
  !  REAL(kind=dp)             :: k0, rate
  !  k0   = a0 * ( d0 + ( TEMP * e0 ) )
  !  rate = k0 * EXP( -b0 / TEMP ) * ( TEMP / 300.0_dp )**c0
  !  IF ( rate < 0.0_dp ) rate = 0.0_dp
  !END FUNCTION ARRPLUS

  FUNCTION ARRPLUS1( a0, b0, d0, e0 ) RESULT( rate )
    ! Modified Arrhenius law, skipping computation of ( T/300 )**c0,
    ! which evaluates to 1 when c0=0.  This avoids excess CPU cycles.
    ! (bmy, 12/18/20)
    !
    REAL(kind=dp), INTENT(IN) :: a0, b0, d0, e0
    REAL(kind=dp)             :: rate
    !
    rate = a0 * ( d0 + ( TEMP * e0 ) ) * EXP( -b0 / TEMP )
    rate = MAX( rate, 0.0_dp )
  END FUNCTION ARRPLUS1

  FUNCTION ARRPLUS2( a0, d0, e0 ) RESULT( rate )
    ! Modified Arrhenius law, skipping computation of EXP( -b0/T )
    ! and ( 300/T )**c0 terms, which evaluate to 1 when b0 = c0 = 0.
    ! This avoids excess CPU cycles. (bmy, 12/18/20)
    !
    REAL(kind=dp), INTENT(IN) :: a0, d0, e0
    REAL(kind=dp)             :: rate
    !
    rate = a0 * ( d0 + ( TEMP * e0 ) )
    rate = MAX( rate, 0.0_dp )
  END FUNCTION ARRPLUS2

  FUNCTION TUNPLUS( a0, b0, c0, d0, e0 ) RESULT( rate )
    REAL(kind=dp), INTENT(IN) :: a0, b0, c0, d0, e0
    REAL(kind=dp)             :: rate
    !
    rate = a0 * ( d0 + ( TEMP * e0 ) )
    rate = rate * EXP( b0 / TEMP ) * EXP( c0 / TEMP**3 )
    rate = MAX( rate, 0.0_dp )
  END FUNCTION TUNPLUS

  FUNCTION GC_ISO1( a0, b0, c0, d0, e0, f0, g0 ) RESULT( rate )
    ! Reaction rate for:
    !    ISOP + OH = LISOPOH + IHOO1
    !    ISOP + OH = LISOPOH + IHOO4
    !
    REAL(kind=dp), INTENT(IN) :: a0, b0, c0, d0, e0, f0, g0
    REAL(kind=dp)             :: k0, k1, k2, rate
    !
    k0   = d0 * EXP( e0 / TEMP ) * EXP( 1.0E8_dp / TEMP**3 )
    k1   = f0 * EXP( g0 / TEMP )
    k2   = c0 * k0 / ( k0 + k1 )
    rate = a0 * EXP( b0 / TEMP ) * ( 1.0_dp - k2 )
  END FUNCTION GC_ISO1

  FUNCTION GC_ISO2( a0, b0, c0, d0, e0, f0, g0 ) RESULT( rate )
    ! Reaction rate for:
    !    ISOP + OH = 0.3MCO3 + 0.3MGLY + 0.3CH2O
    !              + 0.15HPALD3 + 0.25HPALD1 + 0.4HO2
    !              + 0.6CO + 1.5OH + 0.3HPETHNL + LISOPOH
    !    ISOP + OH = 0.3CH2O + 0.15HPALD4 + 0.25HPALD2
    !              + 1.5OH + 0.9CO + 0.7HO2 + 0.3MGLY
    !              + 0.3ATOOH + LISOPOH
    !
    REAL(kind=dp), INTENT(IN) :: a0, b0, c0, d0, e0, f0, g0
    REAL(kind=dp)             :: k0, k1, k2, rate
    !
    k0   = d0 * EXP( e0 / TEMP ) * EXP( 1.0E8_dp / TEMP**3 )
    k1   = f0 * EXP( g0 / TEMP )
    k2   = c0 * k0 / ( k0 + k1 )
    rate = a0 * EXP( b0 / TEMP ) * k2
  END FUNCTION GC_ISO2

  FUNCTION GC_EPO( a1, e1, m1 ) RESULT( rate )
     REAL(kind=dp), INTENT(IN) :: a1, e1, m1
     REAL(kind=dp)             :: k1, rate
     k1   = 1.0_dp / ( m1 * NUMDEN + 1.0_dp )
     rate = a1 * EXP( e1 / TEMP ) *  K1
  END FUNCTION GC_EPO

  FUNCTION GC_PAN( a0, c0, a1, c1, cf ) RESULT( rate )
    ! Reaction rate for
    !    MACR1OO + NO2 = MPAN
    !    MACRNO2 + NO2 = MPAN + NO2
    ! For these reactions, these Arrhenius law terms evaluate to 1:
    !    EXP(b0/T)
    !    EXP(b1/T)
    ! because b0 = b1 = 0.  Therefore we can skip computing these
    ! terms.  This avoids excess CPU cycles. (bmy, 12/18/20)
     REAL(kind=dp), INTENT(IN) :: a0, c0, a1, c1, cf
     REAL(kind=dp)             :: k0, k1, kr, nc, f,  rate
     !
     k0   = a0 * ( TEMP / 300.0_dp )**c0
     k1   = a1 * ( TEMP / 300.0_dp )**c1
     k0   = k0 * NUMDEN
     kr   = k0 / k1
     nc   = 0.75_dp - 1.27_dp * ( LOG10( cf ) )
     f    = 10.0_dp**( LOG10( cf ) / ( 1.0_dp + ( LOG10( kr ) / nc )**2 ) )
     rate = k0 * k1 * f / ( k0 + k1 )
  END FUNCTION GC_PAN

  FUNCTION GC_NIT ( a0, b0, c0, n, x0, y0 ) RESULT( rate )
     REAL(kind=dp), INTENT(IN) :: a0, b0, c0, n,  x0, y0
     REAL(kind=dp)             :: k0, k1, k2, k3, k4, rate
     !
     k0   = 2.0E-22_dp * EXP( n )
     k1   = 4.3E-1_dp * ( TEMP / 298.0_dp )**(-8)
     k0   = k0 * NUMDEN
     k1   = k0 / k1
     k2   = ( k0 / ( 1.0_dp + k1 ) ) &
          * 4.1E-1_dp**( 1.0_dp / ( 1.0_dp + ( LOG10(k1) )**2) )
     k3   = k2 / ( k2 + c0 )
     k4   = A0 * ( x0 - TEMP*y0 )
     rate = k4 * EXP( b0 / TEMP ) * k3
     rate = MAX( rate, 0.0_dp )
  END FUNCTION GC_NIT

  FUNCTION GC_ALK( a0, b0, c0, n, x0, y0 ) RESULT( rate )
     REAL(kind=dp), INTENT(IN) :: a0, b0, c0, n,  x0, y0
     REAL(kind=dp)             :: k0, k1, k2, k3, k4, rate
     !
     k0   = 2.0E-22_dp * EXP( n )
     k1   = 4.3E-1_dp * ( TEMP / 298.0_dp)**(-8)
     k0   = k0 * NUMDEN
     k1   = k0 / k1
     k2   = ( K0 / ( 1.0_dp +K1 ) )                                          &
          * 4.1E-1_dp**( 1.0_dp / ( 1.0_dp + ( LOG10( k1 ) )**2) )
     k3   = c0/ ( k2 + c0 )
     k4   = a0 * ( x0 - TEMP*y0 )
     rate = k4 * EXP( b0 / TEMP ) * k3
     rate = MAX( rate, 0.0_dp )
  END FUNCTION GC_ALK

  FUNCTION GCARR( a0, b0, c0 ) RESULT( rate )
    ! Arrhenius function, using all 3 terms.
    ! Use this when a0, b0, c0 are all nonzero
    !
    REAL(kind=dp), INTENT(IN) :: a0, b0, c0
    REAL(kind=dp)             :: rate
    !
    rate = a0 * EXP( c0 / TEMP ) * ( 300.0_dp / TEMP )**b0
  END FUNCTION GCARR

  FUNCTION GCARR1( a0, b0 ) RESULT( rate )
    ! Arrhenius function, skipping computation of EXP( c0/T ),
    ! which evaluates to 1 when c0=0.  This avoids excess CPU
    ! cycles. (bmy, 12/18/20)
    REAL(kind=dp), INTENT(IN) :: a0, b0
    REAL(kind=dp)             :: rate
    !
    rate = a0 * ( 300.0_dp / TEMP )**b0
  END FUNCTION GCARR1

  FUNCTION GCARR2( a0, c0 ) RESULT( rate )
    ! Arrhenius function, skipping computation of ( 300/T )**b0,
    ! which evaluates to 1 when b0=0.  This avoids excess CPU
    ! cycles (bmy, 12/18/20)
    REAL(kind=dp), INTENT(IN) :: a0, c0
    REAL(kind=dp)             :: rate
    !
    rate = a0 * EXP( c0 / TEMP )
  END FUNCTION GCARR2

  FUNCTION GC_HO2HO2( a0, c0, a1, c1 ) RESULT( rate )
    ! Reaction rate for
    !    HO2 + HO2 = H2O2 + O2
    ! For this reaction, these Arrhenius law terms evaluate to 1:
    !    (300/T)**b0
    !    (300/T)**b1
    ! because b0 = b1 = 0.  Therefore we can skip computing these
    ! terms.  This avoids excess CPU cycles. (bmy, 12/18/20)
    REAL(kind=dp), INTENT(IN) :: a0, c0, a1, c1
    REAL(kind=dp)             :: r0, r1, rate
    !
    r0   = a0 * EXP( c0 / TEMP )
    r1   = a1 * EXP( c1 / TEMP )
    rate = ( r0     + r1         * NUMDEN                           ) &
         * ( 1.0_dp + 1.4E-21_dp * H2O    * EXP( 2200.0_dp / TEMP ) )
  END FUNCTION GC_HO2HO2

  FUNCTION GC_TBRANCH1( a0, c0, a1, c1 ) RESULT( rate )
    ! Temperature Dependent Branching Ratio, used for reactions:
    !    MO2 + MO2 = MOH + CH2O + O2
    !    MO2 + MO2 = 2CH2O + 2HO2
    ! For these reactions, these Arrhenius law terms evaluate to 1:
    !    (300/T)**b0
    !    (300/T)**b1
    ! because b0 = b1 = 0.  Therefore we can skip computing these
    ! terms.  This avoids excess CPU cycles. (bmy, 12/18/20)
    REAL(kind=dp), INTENT(IN) :: a0, c0, a1, c1
    REAL(kind=dp)             :: r0, r1, rate
    !
    r0   = a0 * EXP( c0 / TEMP )
    r1   = a1 * EXP( c1 / TEMP )
    rate = r0 / ( 1.0_dp + r1 )
  END FUNCTION GC_TBRANCH1

  FUNCTION GC_TBRANCH2( a0, c0, a1, b1, c1 ) RESULT( rate )
    ! Temperature Dependent Branching Ratio, used for reactions:
    !    C3H8 + OH = B3O2
    !    C3H8 + OH = A3O2
    ! For these reactions, this Arrhenius law term evaluates to 1:
    !    (300/T)**b0
    ! because b0 = 0.  Therefore we can skip computing this
    ! term.  This avoids excess CPU cycles. (bmy, 12/18/20)
    REAL(kind=dp), INTENT(IN) :: a0, c0, a1, b1, c1
    REAL(kind=dp)             :: r0, r1, rate
    !
    r0   =  a0 * EXP( c0 / TEMP )
    r1   =  a1 * EXP( c1 / TEMP ) * ( 300.0_dp / TEMP )**b1
    rate =  r0 / ( 1.0_dp + r1 )
  END FUNCTION GC_TBRANCH2

  FUNCTION GC_RO2HO2( a0, c0, a1 ) RESULT( rate )
    ! Carbon Dependence of RO2+HO2, used in these reactions:
    !    A3O2 + HO2 = RA3P
    !    PO2  + HO2 = PP
    !    KO2  + HO2 = 0.150OH + 0.150ALD2 + 0.150MCO3 + 0.850ATOOH
    !    B3O2 + HO2 = RB3P
    !    PRN1 + HO2 = PRPN
    ! For these reactions, these Arrhenius law terms evaluate to 1:
    !    (300/T)**b0
    !    (300/T)**b1 * EXP(c1/T)
    ! Because b0 = b1 = c1 = 0.  Therefore we can skip computing these
    ! terms.  This avoids excess CPU cycles. (bmy, 12/18/20)
    REAL(kind=dp), INTENT(IN) :: a0, c0, a1
    REAL(kind=dp)             :: rate
    !
    rate = a0 * EXP( c0 / TEMP )
    rate = rate * ( 1.0_dp - EXP( -0.245_dp * a1 ) )
  END FUNCTION GC_RO2HO2

  FUNCTION GC_DMSOH( a0, c0, a1, c1 ) RESULT( rate )
    ! Reaction rate for:
    !    DMS + OH = 0.750SO2 + 0.250MSA + MO2
    ! For this reaction, these Arrhenius law terms evaluate to 1:
    !    (300/T)**b0
    !    (300/T)**b1
    ! Because b0 = b1 = 0.  Therefore we can skip computing these
    ! terms.  This avoids excess CPU cycles. (bmy, 12/18/20)
    REAL(kind=dp), INTENT(IN) :: a0, c0, a1, c1
    REAL(kind=dp)             :: r0, r1, rate
    r0   = a0 * EXP( c0 / TEMP )
    r1   = a1 * EXP( c1 / TEMP )
    rate = ( r0 * NUMDEN * 0.2095e0_dp ) / ( 1.0_dp + r1 * 0.2095e0_dp )
  END FUNCTION GC_DMSOH

 FUNCTION GC_GLYXNO3( a0, c0 ) RESULT( rate )
    ! Reaction rate for:
    !    GLYX + NO3 = HNO3 + HO2 + 2.000CO
    !    i.e. the HO2 + 2*CO branch
    ! For this reaction, this Arrhenius term evaluates to 1:
    !    (300/T)**b0
    ! because b0 = 0.  Therefore we can skip computing this
    ! term.  This avoids excess CPU cycles. (bmy, 12/18/20)
    !
    REAL(kind=dp), INTENT(IN) :: a0, c0
    REAL(kind=dp)             :: O2, rate
    !
    ! ---  K = K1*([O2]+3.5D18)/(2*[O2]+3.5D18)
    O2   = NUMDEN * 0.2095e0_dp
    rate = a0 * EXP( c0 / TEMP )
    rate = rate * ( O2 + 3.5E+18_dp ) / ( 2.0_dp * O2 + 3.5E+18_dp )
  END FUNCTION GC_GLYXNO3

  FUNCTION GC_OHHNO3( a0, c0, a1, c1, a2, c2 ) RESULT( rate )
    ! Reaction rate for:
    !    HNO3  + OH = H2O + NO3
    !    HONIT + OH = NO3 + HAC
    ! For these reactions, these Arrhenius law terms evaluate to 1:
    !    (300/T)**b0
    !    (300/T)**b1
    !    (300/T)**b2
    ! Because b0 = b1 = b2 = 0.  Therefore we can skip computing
    ! these terms.  This avoids excess CPU cycles. (bmy, 12/18/20)
    REAL(kind=dp), INTENT(IN) :: a0, c0, a1, c1, a2, c2
    REAL(kind=dp)             :: r0, r1, r2, rate
    !
    ! ---  OH + HNO3:   K = K0 + K3[M] / (1 + K3[M]/K2)  ------
    r0   = a0 * EXP( c0 / TEMP )
    r1   = a1 * EXP( c1 / TEMP )
    r2   = NUMDEN * ( a2 * EXP( c2 / TEMP ) )
    rate = r0 + r2 / ( 1.0_dp + r2/r1 )
  END FUNCTION GC_OHHNO3

  FUNCTION GC_GLYCOHA( a0 ) RESULT( rate )
    ! Reaction rate for:
    !    GLYC + OH = 0.732CH2O + 0.361CO2  + 0.505CO    + 0.227OH
    !              + 0.773HO2  + 0.134GLYX + 0.134HCOOH
    ! For this reaction, these Arrhenius law terms evaluate to 1:
    !    (300/T)**b0 * EXP(c0/T)
    ! Because b0 = c0 = 0.  Therefore we can skip computing these
    ! terms.  This avoids excess CPU cycles. (bmy, 12/18/20)
    !
    REAL(kind=dp), INTENT(IN) :: a0
    REAL(kind=dp)             :: glyc_frac, rate
    REAL(kind=dp), PARAMETER  :: exp_arg = -1.0_dp / 73.0_dp
    !
    glyc_frac = 1.0_dp - 11.0729_dp * EXP( exp_arg * TEMP )
    glyc_frac = MAX( glyc_frac, 0.0_dp )
    rate      = a0 * glyc_frac
  END FUNCTION GC_GLYCOHA

  FUNCTION GC_GLYCOHB( a0 ) RESULT( rate )
    ! Reaction rate for:
    !    GLYC + OH = HCOOH + OH + CO
    ! For this reaction, these Arrhenius law terms evaluate to 1:
    !    (300/T)**b0 * EXP(c0/T)
    ! Because b0 = c0 = 0.  Therefore we can skip computing these
    ! terms.  This avoids excess CPU cycles. (bmy, 12/18/20)
    !
    REAL(kind=dp), INTENT(IN) :: a0
    REAL(kind=dp)             :: glyc_frac, rate
    REAL(kind=dp), PARAMETER  :: exp_arg = -1.0_dp / 73.0_dp
    !
    glyc_frac = 1.0_dp - 11.0729_dp * EXP( exp_arg * TEMP )
    glyc_frac = MAX( glyc_frac, 0.0_dp )
    rate      = a0 * ( 1.0_dp - glyc_frac )
  END FUNCTION GC_GLYCOHB

  FUNCTION GC_HACOHA( a0, c0 ) RESULT( rate )
    ! Reaction rate for:
    !    HAC + OH = MGLY + HO2
    ! For this reaction, this Arrhenius law term evaluates to 1:
    !    (300/T)**b0
    ! because b0 = 0.  Therefore we can skip computing this
    ! term.  This avoids excess CPU cycles. (bmy, 12/18/20)
    !
    REAL(kind=dp), INTENT(IN) :: a0, c0
    REAL(kind=dp)             :: r0, hac_frac, rate
    REAL(kind=dp), PARAMETER  :: exp_arg = -1.0_dp / 60.0_dp
    !
    r0       = a0 * EXP( c0 / TEMP )
    hac_frac = 1.0_dp - 23.7_dp * EXP( exp_arg * TEMP )
    hac_frac = MAX( hac_frac, 0.0_dp )
    rate     = r0 * hac_frac
  END FUNCTION GC_HACOHA

  FUNCTION GC_HACOHB( a0, c0 ) RESULT( rate )
    ! Reaction rate for:
    !    HAC + OH = 0.5HCOOH + OH    + 0.5ACTA
    !             + 0.5CO2   + 0.5CO + 0.5MO2 :
    ! For this reaction, this Arrhenius law term evaluates to 1:
    !    (300/T)**b0
    ! because b0 = 0.  Therefore we can skip computing this
    ! term.  This avoids excess CPU cycles. (bmy, 12/18/20)
    !
    REAL(kind=dp), INTENT(IN) :: a0, c0
    REAL(kind=dp)             :: r0, hac_frac, rate
    REAL(kind=dp), PARAMETER  :: exp_arg = -1.0_dp / 60.0_dp
    !
    r0       = a0 * EXP( c0 / TEMP )
    hac_frac = 1.0_dp - 23.7_dp * EXP( exp_arg * TEMP )
    hac_frac = MAX( hac_frac, 0.0_dp )
    rate     = r0 * ( 1.0_dp - hac_frac )
  END FUNCTION GC_HACOHB

  FUNCTION GC_OHCO( a0 ) RESULT( rate )
    ! Reaction rate for:
    !    OH + CO = HO2 + CO2 (cf. JPL 15-10)
    ! For this reaction, these Arrhenius law terms evaluate to 1:
    !    (300/T)**b0 * EXP(c0/T)
    ! because b0 = c0 = 0.  Therefore we can skip computing these
    ! terms.  This avoids excess CPU cycles. (bmy, 12/18/20)
    REAL(kind=dp), INTENT(IN) :: a0
    REAL(kind=dp)             :: r0,     klo1,   klo2,  khi1,    khi2
    REAL(kind=dp)             :: xyrat1, xyrat2, blog1, blog2,   fexp1
    REAL(kind=dp)             :: fexp2,  kco1,   kco2,  TEMP300, rate
    !
    TEMP300 = ( 300.0_dp / TEMP )
    r0      = a0 * ( 1.0_dp + 0.6_dp * 9.871E7_dp * PRESS )
    klo1    = 5.9E-33_dp * TEMP300  !**(1.E+0_dp)
    khi1    = 1.1E-12_dp * TEMP300**(-1.3_dp)
    xyrat1  = klo1 * NUMDEN / khi1
    blog1   = LOG10( xyrat1 )
    fexp1   = 1.0_dp / ( 1.0_dp + blog1*blog1 )
    kco1    = klo1 * NUMDEN * 0.6_dp**fexp1 / ( 1.0_dp + xyrat1 )
    klo2    = 1.5E-13_dp !* TEMP300**(0.E+0_dp)
    khi2    = 2.1E+09_dp * TEMP300**(-6.1_dp)
    xyrat2  = klo2 * NUMDEN / khi2
    blog2   = LOG10( xyrat2 )
    fexp2   = 1.0_dp / ( 1.0_dp + blog2*blog2 )
    kco2    = klo2 * 0.6_dp**fexp2 / ( 1.0_dp + xyrat2 )
    rate    = kco1 + kco2
  END FUNCTION GC_OHCO

  REAL(kind=dp) FUNCTION GC_RO2NO( B,A0,B0,C0,A1,B1,C1 )
    ! ---  K = K1*(1-FYRNO3(K2,M,T))  ---  abstraction branch of RO2+NO
    CHARACTER(*) B !Branch Toggle
    REAL A0,B0,C0,A1,B1,C1
    REAL(kind=dp) :: R0,R1
    REAL(kind=dp) :: YYYN, XXYN,  AAA,  RARB, ZZYN
    REAL(kind=dp) :: XF, ALPHA, Y300, BETA, XMINF, XM0
    REAL(kind=dp) :: FYRNO3
    Y300 = 0.826
    ALPHA= 1.94e-22
    BETA = 0.97
    XM0  = 0.
    XMINF= 8.1
    XF   = 0.411

    R0 =  DBLE(A0) * EXP(DBLE(C0)/TEMP) * (300._dp/TEMP)**DBLE(B0)
    R1 =  DBLE(A1) * EXP(DBLE(C1)/TEMP) * (300._dp/TEMP)**DBLE(B1)

    ! Special treatment for methyl nitrate based on observations
    ! as Carter and Atkinson formulation does not apply to C1.
    ! Value based on upper limit of Flocke et al. 1998 as applied
    ! in Fisher et al. 2018
    IF ( A1 == 1.0 ) THEN
       FYRNO3 = DBLE(3.0e-4)
    ELSE

       ! Initialize static variables
       XXYN   = ALPHA*EXP(BETA*R1)*NUMDEN*((300./TEMP)**XM0)
       YYYN   = Y300*((300./TEMP)**XMINF)
       AAA    = LOG10(XXYN/YYYN)
       ZZYN   = 1./(1.+ AAA*AAA )
       RARB   = (XXYN/(1.+ (XXYN/YYYN)))*(XF**ZZYN)
       FYRNO3 = RARB/(1. + RARB)
    ENDIF

    IF (trim(B) .eq. 'A') THEN
       GC_RO2NO     = R0 * FYRNO3
    ELSEIF (trim(B) .eq. 'B') THEN
       GC_RO2NO     = R0 * (1.E+0_dp - FYRNO3)
    ENDIF

  END FUNCTION GC_RO2NO

  REAL(kind=dp) FUNCTION GCJPL3( k0_300, n, ki_300, m)
    !  Functions given in JPL Booklet
    REAL k0_300, n, ki_300,m
    REAL k0, ki

    k0=k0_300*((TEMP/300.d0)**(-n))
    ki=ki_300*((TEMP/300.d0)**(-m))

    !      GCJPL3=(k0*NUMDEN)/(1+k0*NUMDEN/ki)*0.6** &
    !	((1+((LOG10(k0*NUMDEN/ki))**2d0)**-1.0d0))
    GCJPL3=(k0/(1.d0+k0/(ki/NUMDEN)))*0.6** &
         ((1+((log10(k0/(ki/NUMDEN)))**2d0)**1.0e0))
    GCJPL3=GCJPL3*NUMDEN
  END FUNCTION GCJPL3

  REAL(kind=dp) FUNCTION GCJPLEQ( A0,B0,C0,A1,B1,C1,A2,B2,C2,FV,FCT1,FCT2 )
    ! Function calculates the rate constant of the forward reaction
    ! calculates the equilibrium constant
    ! Find the backwards reaction by K=kforward/kbackwards
    REAL A0,B0,C0,A1,B1,C1
    REAL(kind=dp) :: R0,R1
    REAL, OPTIONAL :: A2,B2,C2,FV,FCT1,FCT2 !If a P-dependent rxn

    ! Calculate Backwards reaction
    R0 = GCARR( A0,B0,C0 )

    ! Calculate forwards reaction
    IF (present(A2)) THEN ! P-dependent
       IF (present(B2) .and. present(C2) .and. present(FV) &
            .and. present(FCT1) .and. present(FCT2)) THEN
          R1 = GCJPLPR( A1,B1,C1,A2,B2,C2,FV,FCT1,FCT2)
       ELSE
          ! Missing params
          write(6,'(a)') 'GCJPLEQ: Missing parameters for P-dependent reaction.'
          write(6,'(a)') 'GCJPLEQ: Returning zero'
          GCJPLEQ = 0.E0
          RETURN
       ENDIF
    ELSE
       R1 = gcarr( A1,B1,C1 ) !Std. Arrhenius eqn.
    ENDIF

    GCJPLEQ=R1/R0
  END FUNCTION GCJPLEQ

  REAL(kind=dp) FUNCTION GCJPLPR(A0,B0,C0,A1,B1,C1,FV,FCT1,FCT2)
    ! * PRESSURE-DEPENDENT EFFECTS
    ! * ADD THE THIRD BODY EFFECT FOR PRESSURE DEPENDENCE OF RATE
    ! * COEFFICIENTS.
    ! A0 B0, & C0 are the Arrhenius parameters for the lower-limit
    ! rate. A1, B1 & C1 are the upper-limit parameters.
    ! FV is the falloff curve paramter, (SEE ATKINSON ET. AL (1992)
    ! J. PHYS. CHEM. REF. DATA 21, P. 1145). USUALLY = 0.6
    !
    REAL A0,B0,C0,A1,B1,C1,FV,FCT1,FCT2
    REAL FCT,XYRAT,BLOG,RLOW,RHIGH,FEXP

    RLOW  = GCARR( A0,B0,C0 )*NUMDEN
    RHIGH = GCARR( A1,B1,C1 )

    IF (FCT2.NE.0.) THEN
       FCT            = EXP(-TEMP / FCT1) + EXP(-FCT2 / TEMP)
       XYRAT          = RLOW/RHIGH
       BLOG           = LOG10(XYRAT)
       FEXP           = 1.e+0_dp / (1.e+0_dp + BLOG * BLOG)
       GCJPLPR        = RLOW*FCT**FEXP/(1e+0_dp+XYRAT)
    ELSEIF (FCT1.NE.0.) THEN
       FCT            = EXP(-TEMP / FCT1)
       XYRAT          = RLOW/RHIGH
       BLOG           = LOG10(XYRAT)
       FEXP           = 1.e+0_dp / (1.e+0_dp + BLOG * BLOG)
       GCJPLPR        = RLOW*FCT**FEXP/(1e+0_dp+XYRAT)
    ELSE
       XYRAT          = RLOW/RHIGH
       BLOG           = LOG10(XYRAT)
       FEXP           = 1.e+0_dp / (1.e+0_dp + BLOG * BLOG)
       GCJPLPR        = RLOW*FV**FEXP/(1e+0_dp+XYRAT)
    ENDIF

  END FUNCTION GCJPLPR

  REAL(kind=dp) FUNCTION GCIUPAC3(ko_300,n,ki_300,m,Fc)
    ! Function calcualtes the rate constant of 3 body reaction using IUPAC
    ! methology
    REAL ko_300,n,ki_300,m,Fc
    REAL ko, ki, F, NN

    ko=ko_300*((TEMP/300.e0)**n)*NUMDEN
    ki=ki_300*((TEMP/300.e0)**m)

    NN=0.75-1.27*LOG10(Fc)
    F=10.0**(LOG10(Fc)/(1.0e0+(LOG10(ko/ki)/NN)**2.0))

    GCIUPAC3=ko/(1+ko/ki)*F
  END FUNCTION GCIUPAC3

#ENDINLINE

#INLINE F90_GLOBAL
  !-----------------------------------------------------------------------
  ! Declare KPP variables that are defined above as THREADPRIVATE
  ! as they are updated for each iteration w/in a parallel loop
  !-----------------------------------------------------------------------
  !$OMP THREADPRIVATE( C, VAR, FIX, RCONST, TIME, TEMP, CFACTOR )

  !-----------------------------------------------------------------------
  ! Add more inlined global parameters for heterogeneous chemistry here
  !-----------------------------------------------------------------------

  ! Minimum heterogeneous chemistry lifetime and reaction rate
  REAL(kind=dp), PARAMETER :: HetMinLife  = 1.e-3_dp
  REAL(kind=dp), PARAMETER :: HetMinRate  = 1.0_dp / HetMinLife

  ! Critical RH for uptake of GLYX, MGLYX, and GLYC:
  REAL(kind=dp), PARAMETER :: CRITRH      = 35.0e+0_dp

  ! Effective Henry's Law constant of IEPOX for reactive
  ! uptake to aqueous aerosols (M/atm)
  REAL(kind=dp), PARAMETER :: HSTAR_EPOX  = 1.7e+7_dp

  ! Conversion factor from atm to bar
  REAL(kind=dp), PARAMETER :: con_atm_bar = 1.0_dp / 1.01325_dp

  ! Universal gas consatant [bar/(mol/kg)/K]  (Source: NIST, 2014)
  ! NOTE: Make sure this is consistent w/ the value in physconsts.F90!
  REAL(kind=dp), PARAMETER :: con_R       = 0.083144598_dp

  !--------------------------------------------------------------------------
  ! Add more global variables here, so that they can be used
  ! in inlined functions that will get written to gckpp_Rates.F90
  !--------------------------------------------------------------------------

  !%%%%% LOGICALS %%%%%%%%%%%%%%%

  LOGICAL :: NATSURFACE, PSCBOX, STRATBOX
  !$OMP THREADPRIVATE( NATSURFACE, PSCBOX, STRATBOX )

  !%%%%% INTEGERS %%%%%%%%%%%%%%%

  INTEGER :: NAEROTYPE
  !$OMP THREADPRIVATE( NAEROTYPE )

  !%%%%% REALS %%%%%%%%%%%%%%%%

  ! Fine SSA+SNA aerosol area [cm2 aerosol/cm3 air]
  REAL(kind=dp) :: AClAREA
  !$OMP THREADPRIVATE( AClAREA )

  ! Fine SSA+SNA aerosol radius [cm]
  REAL(kind=dp) :: AClRADI
  !$OMP THREADPRIVATE( AClRADI )

  ! Fine SSA+SNA aerosol volume (cm3 aerosol/cm3 air)
  REAL(kind=dp) :: AClVOL
  !$OMP THREADPRIVATE( AClVol )

  ! Isorropia aerosol water (coarse & fine modes)
  REAL(kind=dp) :: AWATER(2)
  !$OMP THREADPRIVATE( AWATER )

  ! Proton activity [unitless] and H+ concentration [M]
  ! (assumed equivalent - for now):
  REAL(kind=dp) :: GAMMA_HO2
  !$OMP THREADPRIVATE( GAMMA_HO2 )

  ! H2O concentration
  REAL(kind=dp) :: H2O
  !$OMP THREADPRIVATE( H2O )

  ! Array for heterogeneous rates
  REAL(kind=dp) :: HET(NSPEC,8)
  !$OMP THREADPRIVATE( HET )

  ! Proton activity [unitless] and H+ concentration [M]
  ! (assumed equivalent - for now):
  REAL(kind=dp) :: H_PLUS
  !$OMP THREADPRIVATE( H_PLUS )

  ! KHETI_SLA = sticking coefficients for PSC reactions on SLA
  REAL(kind=dp) :: KHETI_SLA(11)
  !$OMP THREADPRIVATE( KHETI_SLA )

  ! Bisulfate (general acid), nitrate, sulfate concentrations [M]:
  REAL(kind=dp) :: MHSO4, MNO3, MSO4
  !$OMP THREADPRIVATE( MHSO4, MNO3, MSO4 )

  ! Number density
  REAL(kind=dp) :: NUMDEN
  !$OMP THREADPRIVATE( NUMDEN )

  ! Array for photolysis rates
  REAL(kind=dp) :: PHOTOL(1000)
  !$OMP THREADPRIVATE( PHOTOL )

  ! Ice and water mixing ratios (kg ice/kg dry air)
  REAL(kind=dp) :: QICE, QLIQ
  !$OMP THREADPRIVATE( QICE, QLIQ )

  ! Organic mattter to organic carbon ratios
  REAL(kind=dp) :: OMOC_POA, OMOC_OPOA
  !$OMP THREADPRIVATE( OMOC_POA, OMOC_OPOA )

  ! Pressure and relative humidity
  REAL(kind=dp) :: PRESS, RELHUM
  !$OMP THREADPRIVATE( PRESS, RELHUM )

  ! Aerosol concentrations
  REAL(kind=dp) :: SPC_SALA
  !$OMP THREADPRIVATE( SPC_SALA )

  ! Cosine of solar zenith angle
  REAL(kind=dp) :: SUNCOS
  !$OMP THREADPRIVATE( SUNCOS )

  ! Volume of air (cm3)
  REAL(kind=dp) :: VAir
  !$OMP THREADPRIVATE( Vair )

  ! Aerosol specific surface area (cm3 H2O/cm3 air)
  REAL(kind=dp) :: XAREA(25)
  !$OMP THREADPRIVATE( XAREA )

  ! Dry air density [molec/cm3]
  REAL(kind=dp) :: XDENA
  !$OMP THREADPRIVATE( XDENA )

  ! Aerosol water content, cm3(H2O)/cm3(air)
  REAL(kind=dp) :: XH2O(25)
  !$OMP THREADPRIVATE( XH2O )

  ! Aerosol effective radius (cm)
  REAL(kind=dp) :: XRADI(25)
  !$OMP THREADPRIVATE( XRADI )

  ! Square root of temperature [K]
  REAL(kind=dp) :: XTEMP
  !$OMP THREADPRIVATE( XTEMP )

  ! Aerosol specific volume, cm3(aerosol)/cm3(air)
  REAL(kind=dp) :: XVOL(25)
  !$OMP THREADPRIVATE( XVOL )

#ENDINLINE
